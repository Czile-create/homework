<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>&#x6570;&#x636E;&#x7ED3;&#x6784;&#x4E0E;&#x7B97;&#x6CD5;&#x7B2C;&#x4E94;&#x6B21;&#x4F5C;&#x4E1A;</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="数据结构与算法第五次作业">数据结构与算法第五次作业</h1>
<center> 
<b>陈梓乐 19336035
<br>
部分代码可在 <a href="http://www.gitee.com/Czile/homework"> gitee.com/Czile/homework </a> 中找到</b>
</center>
<hr>
<h2 id="1-证明满二叉树的分支数为-b--2n_0---1-n_0-为叶子节点数">1. 证明：满二叉树的分支数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> = 2(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> - 1). <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为叶子节点数</h2>
<p>由性质5-3[1]， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> - 1， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是度数为2的节点数。于是题设要证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> = 2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<p>由满二叉树的性质[2]， 满二叉树只有度数为0和度数为2的节点，于是没有度数为1的节点，每一个度数为2的节点有两个子节点，</p>
<p>因此分支数为度数为2的节点的两倍。[3]</p>
<blockquote>
<p>[1] 王红梅.数据结构与算法(第二版).清华大学出版社.P110.性质5-3</p>
</blockquote>
<blockquote>
<p>[2] 王红梅.数据结构与算法(第二版).清华大学出版社.P108.满二叉树</p>
</blockquote>
<blockquote>
<p>[3] 本题也可用图论中边数等于节点度数和来证明</p>
</blockquote>
<h2 id="2-已知度为-m-的树中有-n_i-个度数为-i-的节点求树中有多少个叶子节点">2. 已知度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的树中，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个度数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的节点，求树中有多少个叶子节点。</h2>
<p>由图论中总度数等于总边数[3]的结论，总度数为： sum(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> · <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</p>
<p>除了根节点外，每个节点有且仅有一个父节点，于是得到结论：节点数 - 1 = 分支数。</p>
<p>于是得到等式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = sum(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> · <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) - sum(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) + 1    [4]</p>
<blockquote>
<p>[4] 本题限定只存在度数为0和度数为2的节点，即可得到性质5-3</p>
</blockquote>
<h2 id="3-已知二叉树的中序遍历和后序遍历分别为-cbedafigh-和-cedbifhga试构造二叉树">3. 已知二叉树的中序遍历和后序遍历分别为 <code>CBEDAFIGH</code> 和 <code>CEDBIFHGA</code>，试构造二叉树。</h2>
<p>使用顺序表来按层表示二叉树如下（空位置用0表示）</p>
<p><code>ABGCDFH00E00I00</code></p>
<h2 id="4-给定一组键值-w--5-2-9-11-8-3-7-试构造haffman-tree并计算带权路径长度">4. 给定一组键值 <code>W = (5, 2, 9, 11, 8, 3, 7)</code> 试构造haffman-tree，并计算带权路径长度。</h2>
<p>构造haffman-tree如下，用haffman编码给出haffman-tree的构造：</p>
<pre><code><code><div>2 - 0000
3 - 0001
5 - 001
11 - 01
7 - 10
8 - 11
</div></code></code></pre>
<h2 id="5-字符串s中各字符出现次数分别为-1-2-3-4-4-5-7-9试问haffman编码">5. 字符串S中各字符出现次数分别为 <code>(1, 2, 3, 4, 4, 5, 7, 9)</code>，试问haffman编码。</h2>
<pre><code><code><div>1 - 00000
2 - 00001
3 - 0001
4 - 100
4 - 101
5 - 001
7 - 11
9 - 01
</div></code></code></pre>
<p>至少两位，至多5位。</p>
<h2 id="6-设计算法求二叉树深度">6. 设计算法求二叉树深度</h2>
<p>不妨假定二叉树是使用顺序储存结构，则代码如下：</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">int</span> <span class="hljs-title">depth</span>(<span class="hljs-title">const</span> <span class="hljs-title">vector</span>&lt;T&gt; &amp;<span class="hljs-title">p</span>) <span class="hljs-title">noexcept</span>{</span>
    <span class="hljs-keyword">return</span> p.size() ? <span class="hljs-keyword">int</span>(log2(p.size())) + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="7-以二叉链表为储存结构设计算法求节点的双亲">7. 以二叉链表为储存结构，设计算法求节点的双亲。</h2>
<pre><code class="language-cpp"><div><span class="hljs-comment">// Find the parent of x</span>
<span class="hljs-comment">// Return a pointer that points to x&#x27;s parent if it exists, else return nullptr</span>
<span class="hljs-comment">// p is the root pointer of the tree that remains to search.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">node</span>&lt;T&gt; * <span class="hljs-title">getParent</span>(<span class="hljs-title">node</span>&lt;T&gt; *<span class="hljs-title">p</span>, <span class="hljs-title">node</span>&lt;T&gt; *<span class="hljs-title">x</span>) {</span>
    <span class="hljs-keyword">if</span> (p -&gt; left &amp;&amp; p -&gt; left == x)
        <span class="hljs-keyword">return</span> p;
    <span class="hljs-keyword">if</span> (p -&gt; right &amp;&amp; p -&gt; right == x) 
        <span class="hljs-keyword">return</span> p;
    node&lt;T&gt; * left, right;
    <span class="hljs-keyword">if</span> (p -&gt; left)
        left = getParent(p -&gt; left, x);
    <span class="hljs-keyword">if</span> (left)
        <span class="hljs-keyword">return</span> left;
    <span class="hljs-keyword">if</span> (p -&gt; right)
        right = getParent(p -&gt; right, x);
    <span class="hljs-keyword">if</span> (right)
        <span class="hljs-keyword">return</span> right;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
}
</div></code></pre>
<h2 id="8-以二叉链表为存储结构删除以值为x的二叉树的子树">8. 以二叉链表为存储结构，删除以值为x的二叉树的子树</h2>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">erase</span>(<span class="hljs-title">node</span>&lt;T&gt;* <span class="hljs-title">p</span>) {</span>
    <span class="hljs-keyword">if</span> (p &amp;&amp; p -&gt; left)
        erase(p -&gt; left);
    <span class="hljs-keyword">if</span> (p &amp;&amp; p -&gt; right)
        erase(p -&gt; right);
    <span class="hljs-keyword">if</span> (p)
        <span class="hljs-keyword">delete</span> p;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">erase</span>(<span class="hljs-title">node</span>&lt;T&gt;* <span class="hljs-title">p</span>, <span class="hljs-title">T</span> &amp; <span class="hljs-title">val</span>) {</span>
    erase(p -&gt; left, val);
    erase(p -&gt; right, val);
    <span class="hljs-keyword">if</span> (p -&gt; val == val)
        erase(p);
}
</div></code></pre>
<h2 id="9-编写算法实现顺序储存的二叉树的前序遍历">9. 编写算法实现顺序储存的二叉树的前序遍历</h2>
<pre><code class="language-cpp"><div><span class="hljs-comment">// Find all element in the tree.</span>
<span class="hljs-comment">// p: The root of the tree</span>
<span class="hljs-comment">// n: the size of the tree if the tree is full</span>
<span class="hljs-comment">// nT: the element if it&#x27;s not an element</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; 
<span class="hljs-title">vector</span>&lt;T&gt; <span class="hljs-title">NLP</span>(<span class="hljs-title">vector</span>&lt;T&gt;:</span>:iterator p, <span class="hljs-keyword">int</span> n, T&amp;nT) {
    <span class="hljs-keyword">if</span> (*p == nT)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;T&gt;();
    <span class="hljs-built_in">vector</span>&lt;T&gt; ans;
    ans.push_back(*p);
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> ans;
    <span class="hljs-keyword">auto</span> tmp = NLP(p + <span class="hljs-number">1</span>, n / <span class="hljs-number">2</span>, nT);
    ans.push_back(ans.end(), tmp.begin(), tmp.end());
    tmp = NLP(p + n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, n / <span class="hljs-number">2</span>, nT);
    ans.push_back(ans.end(), tmp.begin(), tmp.end());
    <span class="hljs-keyword">return</span> ans;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">vector</span>&lt;T&gt; <span class="hljs-title">NLP</span>(<span class="hljs-title">vector</span>&lt;T&gt; &amp; <span class="hljs-title">p</span>) {</span>
    <span class="hljs-keyword">return</span> NLP(p.begin(), p.size(), T());
}
</div></code></pre>
<h2 id="10-编写算法交换所有节点的左右子树">10. 编写算法交换所有节点的左右子树</h2>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(node&lt;T&gt; * p)</span> </span>{
    <span class="hljs-keyword">if</span> (p) {
        swap(p -&gt; left, p -&gt; right);
        swap(p -&gt; left);
        swap(p -&gt; right);
    }
}
</div></code></pre>
<h2 id="11-实现树的各种遍历">11. 实现树的各种遍历</h2>
<h3 id="前序遍历">前序遍历</h3>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">vector</span>&lt;T&gt; <span class="hljs-title">NLR</span>(<span class="hljs-title">node</span>&lt;T&gt; *<span class="hljs-title">p</span>) {</span>
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">auto</span> ans = p -&gt; val;
    <span class="hljs-keyword">auto</span> left = NLP(p -&gt; left);
    <span class="hljs-keyword">auto</span> right = NLP(p -&gt; right);
    ans.insert(ans.end(), left.begin(), left.end());
    ans.insert(ans.end(), right.begin(), right.end());
    <span class="hljs-keyword">return</span> ans;
}
</div></code></pre>
<h3 id="中序遍历">中序遍历</h3>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">vector</span>&lt;T&gt; <span class="hljs-title">LNR</span>(<span class="hljs-title">node</span>&lt;T&gt; *<span class="hljs-title">p</span>) {</span>
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;T&gt;();
    <span class="hljs-keyword">auto</span> ans = NLP(p -&gt; left);
    <span class="hljs-keyword">auto</span> right = NLP(p -&gt; right);
    ans.push_back(p -&gt; val);
    ans.insert(ans.end(), right.begin(), right.end());
    <span class="hljs-keyword">return</span> ans;
}
</div></code></pre>
<h3 id="后序遍历">后序遍历</h3>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">vector</span>&lt;T&gt; <span class="hljs-title">LRN</span>(<span class="hljs-title">node</span>&lt;T&gt; *<span class="hljs-title">p</span>) {</span>
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;T&gt;();
    <span class="hljs-keyword">auto</span> ans = NLP(p -&gt; left);
    <span class="hljs-keyword">auto</span> right = NLP(p -&gt; right);
    ans.insert(ans.end(), right.begin(), right.end());
    ans.push_back(p -&gt; val);
    <span class="hljs-keyword">return</span> ans;
}
</div></code></pre>
<h3 id="层序遍历">层序遍历</h3>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">vector</span>&lt;T&gt; <span class="hljs-title">BFS</span>(<span class="hljs-title">node</span> &lt;T&gt; *<span class="hljs-title">p</span>) {</span>
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;T&gt;();
    <span class="hljs-built_in">queue</span>&lt;node &lt;T&gt; *&gt; q;
    <span class="hljs-built_in">vector</span>&lt;T&gt; ans;
    q.push(p);
    <span class="hljs-keyword">while</span> (q.size()) {
        <span class="hljs-keyword">auto</span> top = q.top();
        q.pop();
        ans.push_back(top -&gt; val);
        <span class="hljs-keyword">if</span> (tmp -&gt; left)
            q.push(tmp -&gt; left);
        <span class="hljs-keyword">if</span> (tmp -&gt; right)
            q.push(tmp -&gt; right);
    }
    <span class="hljs-keyword">return</span> ans;
}
</div></code></pre>
<h2 id="12-编写程序实现各种线索二叉树">12. 编写程序，实现各种线索二叉树</h2>
<h3 id="前序线索二叉树">前序线索二叉树</h3>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> Binarytree&lt;T&gt;::_preorder(
    <span class="hljs-keyword">const</span> Binarytreenode * p,
    thrnode *&amp; y, thrnode *&amp; pre
) <span class="hljs-keyword">noexcept</span> {
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;
    y = <span class="hljs-keyword">new</span> thrnode(p -&gt; val);
    <span class="hljs-keyword">if</span> (pre &amp;&amp; pre -&gt; rtag) pre -&gt; right = y;
    y -&gt; rtag = !(p -&gt; right);
    y -&gt; ltag = !(p -&gt; left);
    <span class="hljs-keyword">if</span> (y -&gt; ltag) y -&gt; left = pre;
    pre = y;
    _preorder(p -&gt; left, y -&gt; left, pre);
    _preorder(p -&gt; right, y -&gt; right, pre);
}
</div></code></pre>
<h3 id="中序线索二叉树">中序线索二叉树</h3>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> Binarytree&lt;T&gt;::_inorder(
    <span class="hljs-keyword">const</span> Binarytreenode * p,
    thrnode *&amp; y, thrnode *&amp; pre
) <span class="hljs-keyword">noexcept</span> {
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;
    y = <span class="hljs-keyword">new</span> thrnode(p -&gt; val);
    _inorder(p -&gt; left, y -&gt; left, pre);
    <span class="hljs-keyword">if</span> (pre &amp;&amp; pre -&gt; rtag) pre -&gt; right = y;
    y -&gt; rtag = !(p -&gt; right);
    y -&gt; ltag = !(p -&gt; left);
    <span class="hljs-keyword">if</span> (y -&gt; ltag) y -&gt; left = pre;
    pre = y;
    _inorder(p -&gt; right, y -&gt; right, pre);
}
</div></code></pre>
<h3 id="后序线索二叉树">后序线索二叉树</h3>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> Binarytree&lt;T&gt;::_postorder(
    <span class="hljs-keyword">const</span> Binarytreenode * p,
    thrnode *&amp; y, thrnode *&amp; pre
) <span class="hljs-keyword">noexcept</span> {
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;
    y = <span class="hljs-keyword">new</span> thrnode(p -&gt; val);
    _postorder(p -&gt; left, y -&gt; left, pre);
    _postorder(p -&gt; right, y -&gt; right, pre);
    <span class="hljs-keyword">if</span> (pre &amp;&amp; pre -&gt; rtag) pre -&gt; right = y;
    y -&gt; rtag = !(p -&gt; right);
    y -&gt; ltag = !(p -&gt; left);
    <span class="hljs-keyword">if</span> (y -&gt; ltag) y -&gt; left = pre;
    pre = y;
}
</div></code></pre>
<h3 id="层序线索二叉树">层序线索二叉树</h3>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">typename</span> Binarytree&lt;T&gt;::thrnode * 
Binarytree&lt;T&gt;::getBFSThrBiTree() <span class="hljs-keyword">noexcept</span> {
    erase(t);
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> t;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;thrnode *&gt; ans;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;Binarytreenode *&gt; tmp;
    <span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>;
    ans.push_back(<span class="hljs-keyword">new</span> thrnode(p -&gt; val));
    tmp.push(p);
    <span class="hljs-keyword">while</span> (i &lt; ans.size()) {
        <span class="hljs-keyword">auto</span> _p = tmp.front();
        <span class="hljs-keyword">if</span> (_p -&gt; left) {
            ans.push_back(
                ans[i] -&gt; left = <span class="hljs-keyword">new</span> thrnode(_p -&gt; left -&gt; val)
            ); 
            tmp.push(_p -&gt; left);
        } <span class="hljs-keyword">else</span> {
            ans[i] -&gt; ltag = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (i) ans[i] -&gt; left = ans[i - <span class="hljs-number">1</span>];
        }
        <span class="hljs-keyword">if</span> (_p -&gt; right) {
            ans.push_back(
                ans[i] -&gt; right = <span class="hljs-keyword">new</span> thrnode(_p -&gt; right -&gt; val)
            ); 
            tmp.push(_p -&gt; right);
        } <span class="hljs-keyword">else</span> {
            ans[i] -&gt; rtag = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (i != ans.size() - <span class="hljs-number">1</span>) ans[i] -&gt; right = ans[i + <span class="hljs-number">1</span>];
        }
        ++i;
        tmp.pop();
    }
    <span class="hljs-keyword">return</span> t = ans[<span class="hljs-number">0</span>];
}
</div></code></pre>
<h2 id="13-使用非递归算法求叶子节点数">13. 使用非递归算法求叶子节点数</h2>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">size_t</span> Binarytree&lt;T&gt;::sizeOfLeaf() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;Binarytreenode*&gt; q;
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (p) q.push(p);
    <span class="hljs-keyword">while</span> (q.size()) {
        <span class="hljs-keyword">auto</span> tmp = q.front();
        <span class="hljs-keyword">if</span> (tmp -&gt; left) q.push(tmp -&gt; left);
        <span class="hljs-keyword">if</span> (tmp -&gt; right) q.push(tmp -&gt; right);
        <span class="hljs-keyword">if</span> (!(tmp -&gt; right || tmp -&gt; left)) ++ans;
        q.pop();
    }
    <span class="hljs-keyword">return</span> ans;
}
</div></code></pre>
<h2 id="14-求字符串的最短编码长度">14. 求字符串的最短编码长度</h2>
<p>本代码模拟haffman-tree建立与应用过程，具体的类定义与实现请参见<a href="06/lab">第六次上机作业第二题</a></p>
<pre><code class="language-cpp"><div><span class="hljs-comment">// @brief 统计所有字符出现的个数</span>
<span class="hljs-function"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; <span class="hljs-title">readfiles</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s)</span> </span>{
    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; charmap;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : s)
        charmap[i] += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> charmap;
}

<span class="hljs-comment">// @brief 根据词频建立小根堆</span>
<span class="hljs-function">heap <span class="hljs-title">make_heap</span><span class="hljs-params">(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; &amp; charmap)</span> </span>{
    heap h;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i: charmap) {
        haffman_tree * tmp = <span class="hljs-keyword">new</span> haffman_tree(i.first, i.second);
        h.push(tmp);
    }
    <span class="hljs-keyword">return</span> h;
}

<span class="hljs-comment">// @brief 根据小根堆建立haffman - tree</span>
<span class="hljs-function">haffman_tree * <span class="hljs-title">make_tree</span><span class="hljs-params">(heap h)</span> </span>{
    <span class="hljs-keyword">if</span> (h.empty())
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;

    <span class="hljs-keyword">while</span> (h.size()&gt;<span class="hljs-number">1</span>) {
        haffman_tree * tmp1 = h.front();
        h.pop();
        haffman_tree * tmp2 = h.front();
        h.pop();
        haffman_tree * tmp = <span class="hljs-keyword">new</span> haffman_tree(tmp1, tmp2);
        h.push(tmp);
    }
    
    <span class="hljs-keyword">return</span> h.front();
}

<span class="hljs-comment">// @brief 根据haffman - tree 获得对应字符的haffman编码</span>
<span class="hljs-function"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">string</span>&gt; <span class="hljs-title">translate</span><span class="hljs-params">(haffman_tree * t)</span> </span>{
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;haffman_tree *, <span class="hljs-built_in">string</span>&gt;&gt; lst;
    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">string</span>&gt; ans;
    lst.push(<span class="hljs-built_in">make_pair</span>(t, <span class="hljs-string">&quot;&quot;</span>));
    <span class="hljs-keyword">while</span> (lst.empty() == <span class="hljs-literal">false</span>) {
        haffman_tree * tmp = lst.front().first;
        <span class="hljs-keyword">if</span> (tmp-&gt;left())
            lst.push(<span class="hljs-built_in">make_pair</span>(
                tmp-&gt;getleft(), lst.front().second + <span class="hljs-string">&quot;0&quot;</span>
            ));
        <span class="hljs-keyword">if</span> (tmp-&gt;right())
            lst.push(<span class="hljs-built_in">make_pair</span>(
                tmp-&gt;getright(), lst.front().second + <span class="hljs-string">&quot;1&quot;</span>
            ));
        <span class="hljs-keyword">if</span> (tmp-&gt;isleaf())
            ans[tmp-&gt;val()]=lst.front().second;
        lst.pop();
    }
    <span class="hljs-keyword">return</span> ans;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{
    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; frequency = readfiles(argv[<span class="hljs-number">0</span>]);
    heap tmp_heap = make_heap(frequency);
    haffman_tree * tree = make_tree(tmp_heap);
    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">string</span>&gt; codetable = translate(tree);
    <span class="hljs-keyword">auto</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: frequency) 
        ans += codetable[i.first].size();
    <span class="hljs-built_in">cout</span> &lt;&lt; ans;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>

    </body>
    </html>